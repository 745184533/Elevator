# Elevator
My first Qt appiliaction
1  分析
1.1 背景分析
每个电梯里面设置必要功能键：如数字键、关门键、开门键、上行键、下行键、报警键、当前电梯的楼层数、上升及下降状态等。
每层楼的每部电梯门口，应该有上行和下行按钮和当前电梯状态的数码显示器。
五部电梯门口的按钮是互联结的，即当一个电梯按钮按下去时，其他电梯的相应按钮也就同时点亮，表示也按下去了。
所有电梯初始状态都在第一层。每个电梯如果在它的上层或者下层没有相应请求情况下，则应该在原地保持不动。
从要求来看是要将每部电梯作为一个独立的线程，不断处理它内部外部请求。从实际中考虑，一个人可以在楼道里的不同楼层按下按钮，同时在电梯内部也可以按下多个按钮（虽然他不一定使用）。因此我在设计过程中不去考虑乘客这个类，只从请求的角度出发，不去考虑这种请求是否合理，只保证电梯内部逻辑正确。
我使用Qt开发，c++语言，使用到了多线程技术。共享内存进行数据操作，但实际中通过逻辑判断避免冲突（没有去使用🔒）。
1.2 功能分析
这个系统应当能及时响应内外部按钮请求，并分配一个电梯去响应。
每部电梯应当有自己的可移动模块，内部显示板（包括楼层按钮、警报、开关门和显示器）。外部楼层每层由上下按钮。所有的按钮在被按下后会变色，在得到响应后变为原来的颜色。同时又输出提示可以去查看。
	当按下故障键以后，电梯会暂停运行，再点击消除故障，会恢复原来的行动。
1.3 算法思想
/*一个电梯是一个线程
//全局线程只是帮助选出对应线程。
//我们需要一个总的请求队列。

//整体逻辑：每当内外有一个按钮被按下的时候，调用SelectLift选择电梯并且跟新对应电梯的下一个目标。
//每次响应总会加入到一个电梯的目标队列中
//所以对于每部电梯来说只需要关注目标队列即可。
//每个按钮的改变和调试信息的输出是在电梯的目标完成时函数实现。
//这个全局线程负责启动各电梯子线程。

//那么临时电梯子线程做的事就是不断的将目标队列里的东西清楚。
//为了实现这个目标每个电梯都应该有一个他自己的目标队列。
*/

/*
全局线程算法：
//1.电梯的空闲当且仅当目标队列为空。
//电梯调度优先选取空闲的电梯。并更新它的目标队列。
//对于运行电梯，选择算法当注意应当有一定的楼层差。
//2.对于正在运行的电梯只有响应处于目标楼层和本楼层之间，才会把它更新为自己的目标楼层。【最前】
//不考虑距离各个电梯比较远近。随便选一个。
//出于安全考虑我们把楼层差而被筛掉的，放到第三种情况里面。
//3.上述两种情况任没有电梯相应。考虑对于正在运行的电梯，随便一个将其添加到它的目标队列中。【最后】
//针对2.3.情况避免全部都分配到同一个电梯。

//这是在简化了楼层按钮方向的考虑后的顺便服务策略。
*/

/*
子线程逻辑：
//子线程一直处于运行状态！！
//对于响应一个目标队列的请求后紧接着响应下一个：
//外部：首先移动函数（主线程）执行完毕，进行一系列操作。
//然后改变该层按钮的颜色（电梯内部的话需要显示面板）（主/子线程），同时调用输出打印信息（主/子线程），
//将目标队列中的相应楼层清除（主线程/子线程）
//（子线程）同时将下一个目标取出，打包信号。
//之后向主线程发出信号（包括目标楼层和方向）让电梯动起来，向目标楼层前进。
//不断循环直到目标队列为空。

//电梯内部响应应当绑定到按键上，一旦有点击立马更新相应的队列

//相应分为两种电梯内部和楼层间的。对于全局线程两者并无区别。
//在目标队列中加以区分，对两种目标完成的调试信息以及按钮改变各不相同。
//

*/
2	设计
2.1 数据结构设计
总体上一个电梯类，楼道类，一个全局子线程类，一个局部子线程类。所有的显示都放在一个MainWindow主窗口类上。
